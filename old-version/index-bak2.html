<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="vue.js"></script>
  <script src="jquery-3.4.1.js"></script>
  <script src="lz-string.js"></script>
  <style>
    :root {
      --dark:       hsl(0, 0%, 10%);
      --dark-gray:  hsl(0, 0%, 30%);
      --gray:       hsl(0, 0%, 60%);;
      --light-gray: hsl(0, 0%, 80%);
      --light:      hsl(0, 0%, 90%);
      --lighter:    hsl(0, 0%, 96%);
      --danger:     hsl(0, 80%, 60%);
      --emphasys:   hsl(240, 100%, 30%);
    }
    table {
      width: 80vw;
      margin: auto;
      border-collapse: collapse;
    }
    tr:not(:first-child):hover {
      background: var(--lighter);
    }
    td:hover {
      background: var(--light);
    }
    td, th {
      /*border: 1px solid hsl(0, 0%, 50%);*/
      border-bottom: 1px solid var(--light-gray);
      border-collapse: collapse;
      padding: .5em;
      text-align: left;
      margin: 0;
      position: relative;
    }
    th {
      border-width: 2px;
      border-color: var(--gray);
    }
    td:first-of-type, th:first-of-type {
      padding-left: 0;
    }
    td:last-of-type, th:last-of-type {
      padding-right: 0;
    }
    td[_title]:hover:after {
      position: absolute;
      /*top: .5em;*/
      background: var(--dark);
      color: var(--light);
      padding: .5em;
      width: 5em;
      word-break: break-all;
      content: attr(_title);
    }
  </style>
</head>
<body>
  <div id="app">
    <form v-on:submit.prevent="process">
      <input type="datetime-local" v-model="from_date" placeholder="from">
      <input type="datetime-local" v-model="to_date" placeholder="from">
      <input type="submit">
    </form>
    <table>
      <thead>
        <tr>
          <th>Committer</th>
          <th>total commits </th>
          <th>total comments</th>
          <th>assigned open issues</th>
          <th>assigned closed issues</th>
          <th>assigned issues commits</th>
          <th>assigned issues comments</th>
        </tr>
      </thead>
      <tbody :key="render_key">
        <tr v-for="user in users">
          <td>{{ user.login }}</td>
          <td>{{ getCommits(user.id).length }}</td>
          <td>{{ getComments(user.id).length }}</td>
          <td :_title="getIssues(user.id).length ? getIssues(user.id).join(' - ') : false">
            {{ getIssues(user.id).length }}
          </td>
        </tr>
      </tbody>
    </table>
    <table>
      <tr>
        <th>Title</th>
        <th>Created at</th>
        <th>Closed at</th>
        <th>Open issues</th>
        <th>Closed issues</th>
      </tr>
      <tr v-for="(milestone, id) in milestones">
        <td>{{ milestone.title }}</td>
        <td>{{ milestone.created_at }}</td>
        <td>{{ milestone.closed_at }}</td>
        <td>{{ milestone.open_issues }}</td>
        <td>{{ milestone.closed_issues }}</td>

        <!-- <td>{{ new Date(milestone.created_at) }}</td> -->
      </tr>
    </table>
    <ul>
      <li v-for="comment in comments">
        <pre>{{comment}}</pre>
      </li>
    </ul>
  </div>
  <script src="functions.js"></script>
  <script>
    let app = new Vue({
      el: '#app',
      data: {
        // message: 'Hello'
        milestones: [],
        commits: [],
        issues: [],
        users: [],
        comments: [],

        user_commits: {},
        user_comments: {},

        period_data: {
          user_commits: {},
          user_comments: {},
          user_issues: {},
        },
        should_update_period: true,

        from_date: '2019-09-10T00:00:00',
        to_date: '2019-09-24T23:00:00',
        render_key: 0,
      },
      watch: {
        from_date: function(oldV, newV) {
          this.should_update_period = true;
        },
        to_date: function(oldV, newV) {
          this.should_update_period = true;
        }
      },
      methods: {
        updateData: function() {
          // console.log('vai atualizar?');
          if (!this.should_update_period) return;
          // console.log('vai !');

          this.period_data.user_commits = this.getPeriodCommits();
          this.period_data.user_comments = this.getPeriodComments();
          this.period_data.user_issues = this.getPeriodIssues();

          this.should_update_period = false;
        },
        getPeriodCommits: function() {
          var data = {};
          this.users.map(u => {
            data[u.id] = [];
            if (!this.user_commits[u.id]) return;
            data[u.id] = this.user_commits[u.id]
              .filter(commit => this.inRange(commit.commit.author.date));
          });
          return data;
        },
        getPeriodComments: function() {
          var data = {};
          this.users.map(u => {
            data[u.id] = [];
            if (!this.user_comments[u.id]) return;
            data[u.id] = this.user_comments[u.id]
              .filter(commit => this.inRange(comment.created_at));
          });
          return data;
        },
        getPeriodIssues: function() {
          data = {};
          this.users.map(u => {
            data[u.id] = [];
          });
          this.issues.map(issue => {
            issue.events
              .filter(e =>
                (e.event == 'assigned' || e.event == 'unassigned') &&
                new Date(e.created_at).getTime() <= this.toTime()
              )
              .map(event => {
                var u_id = event.assignee.id;
                switch(event.event) {
                  case 'assigned':
                    if (!data[u_id]) {
                      this.addUser(event.assignee);
                      data[u_id] = [];
                    }
                    data[u_id].push(issue.number);
                    break;
                  case 'unassigned':
                    data[u_id].splice(data[u_id].indexOf(issue.number), 1);
                    break;
                }
              });
          });
          return data;
        },


        getCommits: function(user_id) {
          this.updateData();
          // if (!this.period_data.user_commits[user_id]) return [];
          return this.period_data.user_commits[user_id] || [];
        },
        getComments: function(user_id) {
          this.updateData();
          // if (!this.period_data.user_comments[user_id]) return [];
          return this.period_data.user_comments[user_id] || [];
        },
        getIssues: function(user_id) {
          this.updateData();
          // if (!this.period_data.user_issues[user_id]) return [];
          return this.period_data.user_issues[user_id] || [];
        },
        getOpenIssues: function() {

        },
        process: function() {
          this.updateData();
          this.render_key++;
        },

        updateIssues: function() {

        },

        inRange: function(dateString) {
          return new Date(dateString).getTime() >= this.fromTime() &&
            new Date(dateString).getTime() <= this.toTime();
        },
        fromTime: function() {
          return new Date(this.from_date).getTime();
        },
        toTime: function() {
          return new Date(this.to_date).getTime();
        },

        addUser: function(user) {
          if (!user || !user.id) return;
          if (this.users.filter(u => u.id == user.id).length == 0) {
            this.users.push(user);
          }
          this.users = this.users.sort((a, b) => a.login.localeCompare(b.login));
          this.should_update_period = true;
        }
      },
      mounted: function() {
        let app = this;

        // let repo = 'Murielson/SGM';
        // let repo = 'KevinSousa/ctic';
        // let repo = 'gmatheus66/OSON';
        let repo = 'gmatheus66/reqon';
        let all_milestones_url = `https://api.github.com/repos/${repo}/milestones?state=all`;
        let all_issues_url = `https://api.github.com/repos/${repo}/issues?state=all`;

        let commits_url = `https://api.github.com/repos/${repo}/commits`;
        let comments_url = `https://api.github.com/repos/${repo}/comments`;

        getGithubData(all_issues_url).then((data) => {
          for (issue of data) {
            ((issue) => {
              if (issue.milestone != null) {
                let milestone = issue.milestone;
                let id = milestone.id;
                // console.log(milestone);
                if (app.milestones.filter(m => m.id == id).length == 0) {
                  app.milestones.push(milestone);
                }
                // app.milestones = app.milestones.concat(milestone);
                // app.milestones[milestone.id] = milestone;
              }
              var eventsCompleted = false;
              var commentsCompleted = (issue.comments == 0);

              getGithubData(issue.events_url).then(data => {
                issue.events = data;
                eventsCompleted = true;
              });
              if (!commentsCompleted) {
                getGithubData(issue.comments_url).then((data) => {
                  issue.comments_obj = data;
                  commentsCompleted = true;
                });
              }

              wait( () => (eventsCompleted && commentsCompleted) ).then(() => {
                this.issues.push(issue);

                if (issue.comments > 0) {
                  // console.log(issue);
                  for (comment of issue.comments_obj) {
                    this.addUser(comment.user);
                    if (!this.user_comments[comment.user.id]) {
                      this.user_comments[comment.user.id] = [];
                    }
                    this.user_comments[comment.user.id].push(comment);
                  }
                }

                this.should_update_period = true;
              });
            })(issue);
          }
        });

        getGithubData(commits_url).then((data) => {
          this.commits = data;
          for (commit of this.commits) {
            // if (commit.author && commit.author.login && commit.committer && commit.committer.login && commit.author.login == commit.committer.login) {
            //   continue;
            // }
            if (!commit.commit || !commit.author) {
              continue;
            }
            this.addUser(commit.author);

            if (!this.user_commits[commit.author.id]) {
              this.user_commits[commit.author.id] = [];
            }
            this.user_commits[commit.author.id].push(commit);
          }
          this.users = this.users.sort((a, b) => a.login.localeCompare(b.login));
        });

        getGithubData(comments_url).then((data) => {
          this.comments = data;
        });

      }
    });
  </script>
</body>
</html>