<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="vue.js"></script>
  <script src="jquery-3.4.1.js"></script>
  <script src="lz-string.js"></script>
  <style>
    :root {
      --dark:       hsl(0, 0%, 10%);
      --dark-gray:  hsl(0, 0%, 30%);
      --gray:       hsl(0, 0%, 60%);;
      --light-gray: hsl(0, 0%, 80%);
      --light:      hsl(0, 0%, 90%);
      --lighter:    hsl(0, 0%, 96%);
      --danger:     hsl(0, 80%, 60%);
      --emphasys:   hsl(240, 100%, 30%);
    }
    table {
      width: 80vw;
      margin: auto;
      border-collapse: collapse;
    }
    tr:not(:first-child):hover {
      background: var(--lighter);
    }
    td, th {
      /*border: 1px solid hsl(0, 0%, 50%);*/
      border-bottom: 1px solid var(--light-gray);
      border-collapse: collapse;
      padding: .5em;
      text-align: left;
      margin: 0;
    }
    th {
      border-width: 2px;
      border-color: var(--gray);
    }
    td:first-of-type, th:first-of-type {
      padding-left: 0;
    }
    td:last-of-type, th:last-of-type {
      padding-right: 0;
    }
  </style>
</head>
<body>
  <div id="app">
    <table>
      <tr>
        <th>Title</th>
        <th>Created at</th>
        <th>Closed at</th>
        <th>Open issues</th>
        <th>Closed issues</th>
      </tr>
      <tr v-for="(milestone, id) in milestones">
        <td>{{ milestone.title }}</td>
        <td>{{ milestone.created_at }}</td>
        <td>{{ milestone.closed_at }}</td>
        <td>{{ milestone.open_issues }}</td>
        <td>{{ milestone.closed_issues }}</td>

        <!-- <td>{{ new Date(milestone.created_at) }}</td> -->
      </tr>
    </table>
  </div>
  <script>
    var $Promise = function(fn) {
      var isResolved = isRejected = false;

      var promise = new Promise(fn);
      return promise.then(
        (f) => {
          isResolved = true;
          isRejected = false;
          return f;
        },
        (f) => {
          isResolved = false;
          isRejected = false;
          return f;
        }
      );
    }

    var wait_finish = timeout => {
      return new Promise((r, j) => {
        var check = () => {
          // console.log(open_issues, closed_issues);
          if (open_issues && closed_issues) r();
          else if ((timeout -= 100) < 0) j('time out');
          else setTimeout(check, 100);
        }
        check();
      });
    }

    var waitResolved = (promises, timeout) =>
      new Promise((res, rej) => {
        var check = () => {
          // console.log(open_issues, closed_issues);
          let resolved = promises.reduce((r, $promise) => {
            console.log($promise);
            return r && $promise.isResolved;
          }, true);

          if (resolved) res();
          else if ((timeout -= 100) < 0) rej('time out');
          else setTimeout(check, 100);
        }
        check();
      });

    let wait = verification =>
      new Promise(res => {
        let check = () => {
          if (verification()) res();
          else setTimeout(check, Math.random() * 50);
        }
        check();
      });

    let cacheFileLock = false;
    let cache = {};
    let cacheLoaded = false;
    let loadCache = reload => {
      if (reload) {
        cache = {};
        return;
      }
      if (cacheLoaded) {
        return;
      }
      if (localStorage.getItem('github_cache')) {
        try {
          cache = JSON.parse(
            LZString.decompress(
              localStorage.getItem('github_cache')
            )
          );
        } catch (e) {
          localStorage.removeItem('github_cache');
        }
      }
      cacheLoaded = true;
    }

    let cachedGithubAjax = (url, success, reload) => {
      reload = reload || false;

      loadCache(false);
      if (!reload && cache[url]) {
        console.log(`getting from cache: ${url}`);
        [data, status, linkHeader] = cache[url];
        return success(data, status, linkHeader);
      }

      return $.get({
        url: url,
        success: (data, status, headers) => {
          var linkHeader = headers.getResponseHeader('link') || false;
          success(data, status, linkHeader);

          wait(() => cacheFileLock == false).then(() => {
            cacheFileLock = true;

            loadCache(false);
            cache[url] = [data, status, linkHeader];
            // console.log(cache);
            var cacheData = JSON.stringify(cache);
            console.log('compressing data...');
            cacheData = LZString.compress(cacheData);
            // console.log('putting into cache: ' + cacheData);
            console.log(`putting into cache: ${url}`)
            localStorage.setItem('github_cache', cacheData);

            cacheFileLock = false;
          });

        }
      });
    }

    let getGithubData = (url, reload) =>
      new Promise(ok => {
        reload = reload || false;

        cachedGithubAjax(url, (data, status, linkHeader) => {
          var _data = [];
          _data.push(data);

          var _links = linkHeader || false;
          if (_links == false) return ok(_data.flat());

          var links = _links
            .split(',')
            .reduce((obj, link) => {
              let match = link.match(/<(.*?page=(\d+).*)>; rel="(.*?)"/);
              // console.log(match);
              obj[match[3]] = [match[1], match[2]];
              return obj;
            }, {});

            var link_ptrn = links['next'][0];
            var first = parseInt(links['next'][1]);
            var last = parseInt(links['last'][1]);
            // console.log(first, last);

            var ajax_calls = [];
            for (i = first; i <= last; i++) {
              ajax_calls.push(
                cachedGithubAjax(
                  link_ptrn.replace(/page=(\d+)/, `page=${i}`),
                  (data) => {
                    _data.push(data);
                  }
                )
              );
            }
            $.when.apply(null, ajax_calls).then(() => {
              // console.log('abacou...');
              ok(_data.flat());
            })

            // waitResolved(promises, 2000).then(ok());

          // if (links['next'][0] != links['last'][0]) {
          //   get_issues(links['next'][0]).then(() => ok());
          // } else {
          //   ok();
          // }
        }, reload);
      });
  </script>
  <script>
    let app = new Vue({
      el: '#app',
      data: {
        // message: 'Hello'
        milestones: [],
        issues: []
      },
      mounted: function() {
        let app = this;

        // let repo = 'Murielson/SGM';
        let repo = 'KevinSousa/ctic';
        // let repo = 'gmatheus66/OSON';
        // let open_issues_url = `https://api.github.com/repos/${repo}/issues?state=open`;
        // let closed_issues_url = `https://api.github.com/repos/${repo}/issues?state=closed`;
        // let closed_milestones_url = `https://api.github.com/repos/${repo}/milestones?state=closed`;

        // let open_milestones_url = `https://api.github.com/repos/${repo}/milestones?state=open`;
        let all_milestones_url = `https://api.github.com/repos/${repo}/milestones?state=all`;
        let all_issues_url = `https://api.github.com/repos/${repo}/issues?state=all`;

        let commits_url = `https://api.github.com/repos/${repo}/commits`;
        let comments_url = `https://api.github.com/repos/${repo}/comments`;

        // $.get({
        //   url: closed_milestones_url,
        //   success: function(data) {
        //     app.milestones = data;
        //     console.log(data);
        //   }
        // });
        // $.get({
        //   url: open_milestones_url,
        //   success: function(data) {
        //     app.milestones = app.milestones.concat(data);
        //     console.log(data);
        //   }
        // });

        // let open_issues, closed_issues = false;
        // $.get({
        //   url: open_issues_url,
        //   success: function(data) {
        //     // app.milestones = app.milestones.concat(data);
        //     console.log(data.length);
        //     app.issues = app.issues.concat(data)
        //     open_issues = true;
        //   }
        // });
        // $.get({
        //   url: closed_issues_url,
        //   success: function(data) {
        //     // app.milestones = app.milestones.concat(data);
        //     // console.log(data);
        //     console.log(data.length);
        //     app.issues = app.issues.concat(data)
        //     closed_issues = true;
        //   }
        // });


        getGithubData(all_issues_url).then((data) => {
          app.issues = data;
          for (issue of app.issues) {
            if (issue.milestone != null) {
              let milestone = issue.milestone;
              let id = milestone.id;
              // console.log(milestone);
              if (app.milestones.filter(m => m.id == id).length == 0) {
                app.milestones.push(milestone);
              }
              // app.milestones = app.milestones.concat(milestone);
              // app.milestones[milestone.id] = milestone;
            }
            if (issue.comments > 0) {
              getGithubData(issue.comments_url).then((data) => {
                issue.comments_obj = data;
              });
            }
          }
        });

        getGithubData(commits_url).then((data) => {
          app.commits = data;
        });

        getGithubData(comments_url).then((data) => {
          app.comments = data;
        })

        // wait_finish(2000).then(
        //   () => {
        //     console.log(app.issues);
        //     for (issue of app.issues) {
        //       if (issue.milestone != null) {
        //         let milestone = issue.milestone;
        //         let id = milestone.id;
        //         // console.log(milestone);
        //         if (app.milestones.filter(m => m.id == id).length == 0) {
        //           app.milestones.push(milestone);
        //         }
        //         // app.milestones = app.milestones.concat(milestone);
        //         // app.milestones[milestone.id] = milestone;
        //       }
        //     }
        //     // console.log(app.milestones);
        //   },
        //   () => {
        //     alert('Os dados não foram carregados');
        //   }
        // );
      }
    });
  </script>
</body>
</html>